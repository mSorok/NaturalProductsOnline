package de.unijena.cheminf.naturalproductsonline.controller


import de.unijena.cheminf.naturalproductsonline.coconutmodel.mongocollections.UniqueNaturalProduct
import de.unijena.cheminf.naturalproductsonline.coconutmodel.mongocollections.UniqueNaturalProductRepository
import org.openscience.cdk.exception.CDKException
import org.openscience.cdk.exception.InvalidSmilesException
import org.openscience.cdk.interfaces.IAtomContainer
import org.openscience.cdk.isomorphism.Ullmann
import org.openscience.cdk.silent.SilentChemObjectBuilder
import org.openscience.cdk.smiles.SmiFlavor
import org.openscience.cdk.smiles.SmilesGenerator
import org.openscience.cdk.smiles.SmilesParser
import org.springframework.data.domain.PageRequest
import org.springframework.data.domain.Pageable
import org.springframework.data.domain.Slice
import org.springframework.web.bind.annotation.RequestMapping
import org.springframework.web.bind.annotation.RequestParam
import org.springframework.web.bind.annotation.RestController
import java.net.URLDecoder

@RestController
@RequestMapping("/api")
class ApiController(val uniqueNaturalProductRepository: UniqueNaturalProductRepository) {
    /*
    * custom api code goes here
    *
    * basic REST-API generated by Spring
    * see @RepositoryRestResource annotation in repository class(es)
    *
    */

    val smilesParser: SmilesParser = SmilesParser(SilentChemObjectBuilder.getInstance())
    val smilesGenerator: SmilesGenerator = SmilesGenerator(SmiFlavor.Unique)

    @RequestMapping("/search/structure")
    fun structureSearchBySmiles(@RequestParam("smiles") smiles: String): Map<String, Any> {
        return this.doStructureSearchBySmiles(URLDecoder.decode(smiles.trim(), "UTF-8"))
    }

    @RequestMapping("/search/substructure")
    fun substructureSearch(@RequestParam("smiles") smiles: String): Map<String, Any> {
        return this.doSubstructureSearch(URLDecoder.decode(smiles.trim(), "UTF-8"))
    }

    @RequestMapping("/search/simple")
    fun simpleSearch(@RequestParam("query") queryString: String): Map<String, Any> {
        /* switch between simple and simple heuristic search
        * the latter tries to guess the input type that could become harder with more search options
        */
        return this.doSimpleSearchWithHeuristic(URLDecoder.decode(queryString.trim(), "UTF-8"))
        // return this.doSimpleSearch(URLDecoder.decode(queryString.trim(), "UTF-8"))
    }

    fun doStructureSearchBySmiles(smiles: String): Map<String, Any> {
        try {
            val parsedSmiles: IAtomContainer = this.smilesParser.parseSmiles(smiles)
            val canonicalSmiles: String = this.smilesGenerator.create(parsedSmiles)

            val results = this.uniqueNaturalProductRepository.findByClean_smiles(canonicalSmiles)

            return mapOf(
                    "originalQuery" to canonicalSmiles,
                    "count" to results.size,
                    "naturalProducts" to results
            )

        } catch (e: InvalidSmilesException) {
            error("An InvalidSmilesException occured: ${e.message}")
        } catch (e: CDKException) {
            error("A CDKException occured: ${e.message}")
        }
    }

    fun doSubstructureSearch(smiles: String): Map<String, Any> {
        try {
            val parsedSubstructureSmiles: IAtomContainer = this.smilesParser.parseSmiles(smiles)
            val pattern = Ullmann.findSubstructure(parsedSubstructureSmiles)

            val hits = mutableListOf<UniqueNaturalProduct>()
            var hitsCount: Int = 0

            // do not fetch all at once since this would have insane memory requirements
            var pageable: Pageable = PageRequest.of(0, 1000)
            var slice: Slice<UniqueNaturalProduct>

            while (true) {
                slice = this.uniqueNaturalProductRepository.findAll(pageable)
                val uniqueNaturalProducts: List<UniqueNaturalProduct> = slice.content

                for (uniqueNaturalProduct in uniqueNaturalProducts) {
                    println(uniqueNaturalProduct.smiles)
                    val parsedSmiles: IAtomContainer = this.smilesParser.parseSmiles(uniqueNaturalProduct.getSmiles())
                    val match = pattern.match(parsedSmiles);

                    // do not save all hits since this would have insane memory requirements for simple and often reoccurring substructures
                    if (match.isNotEmpty()) {
                        hitsCount++

                        if (hitsCount < 250) {
                            hits.add(uniqueNaturalProduct)
                        }
                    }
                }

                if (!slice.hasNext()) {
                    break
                }

                pageable = slice.nextPageable()
            }

            return mapOf(
                    "originalQuery" to smiles,
                    "count" to hitsCount,
                    "naturalProducts" to hits
            )

        } catch (e: InvalidSmilesException) {
            error("An InvalidSmilesException occured: ${e.message}")
        } catch (e: CDKException) {
            error("A CDKException occured: ${e.message}")
        }
    }


    fun doSimpleSearch(query: String): Map<String, Any> {
        val naturalProducts = mutableSetOf<UniqueNaturalProduct>()

        naturalProducts += this.uniqueNaturalProductRepository.findBySmiles(query)
        naturalProducts += this.uniqueNaturalProductRepository.findByClean_smiles(query)
        naturalProducts += this.uniqueNaturalProductRepository.findByInchi(query)
        naturalProducts += this.uniqueNaturalProductRepository.findByInchikey(query)
        naturalProducts += this.uniqueNaturalProductRepository.findByMolecular_formula(query)

        return mapOf(
                "originalQuery" to query,
                "naturalProducts" to naturalProducts
        )
    }

    fun doSimpleSearchWithHeuristic(query: String): Map<String, Any> {
        // determine type of input on very basic principles without validation
        val regexMap: Map<String, Regex> = mapOf(
                "inchi" to Regex("^InChI=.*$"),
                "inchikey" to Regex("^[A-Z]{14}-[A-Z]{10}-[A-Z]$"),
                "molecular_formula" to Regex("C[0-9]+?H[0-9].+"),
                "smiles" to Regex("^[^Jj][A-Za-z0-9\\(\\)\\[\\]\\-=#$:\\+\\@\\.\\/\\>\\<]{3,}$")
                // "molecular_weight" to Regex("^\\d+?[.,]?\\d+?$")
        )

        val hitsMap = mutableMapOf<String, Boolean>()

        for ((name, regex) in regexMap) {
            hitsMap[name] = regex.containsMatchIn(query)
        }

        // only search by smiles if no other formats match; problem: smiles matches almost everything
        val naturalProducts: List<UniqueNaturalProduct> = when {
            hitsMap["inchi"]!! -> this.uniqueNaturalProductRepository.findByInchi(query)
            hitsMap["inchikey"]!! -> this.uniqueNaturalProductRepository.findByInchikey(query)
            hitsMap["molecular_formula"]!! -> this.uniqueNaturalProductRepository.findByMolecular_formula(query)
            hitsMap["smiles"]!! -> this.uniqueNaturalProductRepository.findBySmiles(query) // this.doStructureSearchBySmiles(query)
            else -> emptyList()
        }

        val determinedInputType: String = when {
            hitsMap["inchi"]!! -> "InChI"
            hitsMap["inchikey"]!! -> "InChIKey"
            hitsMap["molecular_formula"]!! -> "molecular formula"
            hitsMap["smiles"]!! -> "SMILES"
            else -> ""
        }

        return mapOf(
                "originalQuery" to query,
                "determinedInputType" to determinedInputType,
                "naturalProducts" to naturalProducts
        )
    }
}